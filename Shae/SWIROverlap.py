import os
import gc
import glob
import cv2
import pickle
import datetime as dt
import numpy as np
import matplotlib.pyplot as plt
from skimage.morphology import square, erosion
from scipy.ndimage.filters import gaussian_filter
from scipy.interpolate import interp1d
import util.boxutil as boxutil


def Vein_SWIR_Threshold(SWIR_dir, vein_mask, tubeID, min_area=100):
    '''Function that loads the 1900 depth wavelength feature pickle generated from and
        thresholds the gnerated mask by unet for for vein detection by overlaping the detected veins and their hyperspectral values.

        Returns a mask that is true, where the hyperspectral and Unet vein masks overlap when in areas when vein is detected. 
    '''
    # Check if SWIR data is available
    loaded_SWIR_tube = None
    if os.path.exists(SWIR_dir):
        SWIR_data_files = os.path.join(SWIR_dir, tubeID + "_1900_features.pickle")
        if SWIR_data_files:
            with open(SWIR_data_files, 'rb') as file:
                loaded_SWIR_tube = pickle.load(file)

    vein_mask_filtered=np.zeros_like(vein_mask)
    
    if loaded_SWIR_tube is not None:
        print("SWIRdata shape:", loaded_SWIR_tube[0].shape)
        hyperspectral_pickle = np.array(loaded_SWIR_tube[0], dtype=np.uint8)
        hyperspectral_resize_RGB = cv2.resize(hyperspectral_pickle, (vein_mask.shape[1], vein_mask.shape[0]))

        # Find the hyperspectral values of the vein rgb mask by overlapping the it on the hyperspectral data
        hyperspectral_values_vein = hyperspectral_resize_RGB[vein_mask[:, :, 0] == 255]

        # Convert data to the appropriate data type for OpenCV
        hyperspectral_values_vein = np.array(hyperspectral_values_vein, dtype=np.uint8)

        # Calculate the histogram of pixel values to find the best threshold based on vein hyperspectral values
        histogram, bins = np.histogram(hyperspectral_values_vein.flatten(), bins=256, range=[0, 256])

        # Find the best threshold using Otsu's method
        total_pixels = hyperspectral_values_vein.shape[0]
        sum_total = np.sum(np.arange(256) * histogram)
        background_sum = 0
        foreground_sum = sum_total
        background_count = 0
        foreground_count = total_pixels

        best_threshold = 0
        best_variance = 0

        for t in range(256):
            background_count += histogram[t]
            foreground_count -= histogram[t]

            if background_count == 0 or foreground_count == 0:
                continue

            background_sum += t * histogram[t]
            foreground_sum = sum_total - background_sum

            background_mean = background_sum / background_count
            foreground_mean = foreground_sum / foreground_count

            between_class_variance = (background_count / total_pixels) * (foreground_count / total_pixels) * (
                        background_mean - foreground_mean) ** 2

            if between_class_variance > best_variance:
                best_variance = between_class_variance
                best_threshold = t - 3

        # Apply the best threshold to binarize the hyperspectral image
        _, thresholded_hyperspectral = cv2.threshold(hyperspectral_resize_RGB, best_threshold, 255, cv2.THRESH_BINARY)

        # Find overlapping regions in the vein mask generated by RGB using U-Net and the vein mask generated by thresholding hyperspectral
        overlap_vein_RGBandSWIR = cv2.bitwise_and(thresholded_hyperspectral, vein_mask[:, :, 0])
        
        additional_vein_RGBandSWIR = cv2.subtract(thresholded_hyperspectral, vein_mask[:, :, 0])
        #Combine the overlapping regions and additional_mask1
        threshold_RGBandSWIR = cv2.add(overlap_vein_RGBandSWIR, additional_vein_RGBandSWIR)
        #Create a binary mask by thresholding the modified mask
        _, threshold_RGBandSWIR_binary = cv2.threshold(overlap_vein_RGBandSWIR, 1, 255, cv2.THRESH_BINARY)

        # Find connected components in the modified mask
        num_labels, labels, stats, _ = cv2.connectedComponentsWithStats(threshold_RGBandSWIR_binary)

        # Create a mask with components larger than the specified area removed
        for label in range(1, num_labels):  # Exclude background label 0
            if stats[label, cv2.CC_STAT_AREA] >= min_area:
                vein_mask_filtered[labels == label] = 255
    else:
        print('SWIR pickle not found for tube:', tubeID, flush=True)

    return vein_mask_filtered
